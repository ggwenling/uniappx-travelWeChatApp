import type { Plugin } from "vite";
import { config, SAFE_CHAR_MAP } from "../config";
import {
	addScriptContent,
	getClassNames,
	getDynamicClassNames,
	isTailwindClass,
	toSafeClass
} from "./utils";

/**
 * class 类名转换
 * @returns
 */
export function classPlugin(): Plugin {
	return {
		name: "vite-cool-unix-tailwind-class",
		enforce: "pre",

		async transform(code, id) {
			// 判断是否为 uvue 文件
			if (id.endsWith(".uvue") || id.includes(".uvue?type=page")) {
				// 避免影响到其他模块/插件
				if (id.includes("uni_modules/") && !id.includes("uni_modules/cool-")) {
					return null;
				}

				// 解析代码
				code = parseCode(code) ?? "";

				if (code) {
					return {
						code,
						map: { mappings: "" }
					};
				}
			}

			return null;
		}
	};
}

interface TagInfo {
	fullTag: string;
	tagName: string;
	attributes: string;
	closing: string;
	startPos: number;
	endPos: number;
}

/**
 * 转换类名中的特殊字符为安全字符（包括 dark: 中的冒号）
 */
function toSafeClassWithDark(className: string): string {
	if (config.utsPlatform === "web" || className.includes(":host")) {
		return className;
	}

	// 如果是表达式,则不进行转换
	if (["!=", "!==", "?", ":", "="].includes(className)) {
		return className;
	}

	let result = className.replace(/\\/g, ""); // 移除转义字符

	// 替换特殊字符（包括 dark: 中的冒号）
	for (const [char, replacement] of Object.entries(SAFE_CHAR_MAP)) {
		if (result.includes(char)) {
			result = result.replace(new RegExp("\\" + char, "g"), replacement);
		}
	}

	return result;
}

/**
 * 获取 class 和 :class 中的类名（不包括 :pt）
 */
function getClassNamesExcludingPt(code: string): string[] {
	const classNames = new Set<string>();

	// 1. 提取静态 class 属性
	const staticClassRegex = /(?:^|\s)class\s*=\s*(['"`])([^'"`]*?)\1/gi;
	let match;
	while ((match = staticClassRegex.exec(code)) !== null) {
		const value = match[2].trim();
		value.split(/\s+/).forEach((name) => name && classNames.add(name));
	}

	// 2. 提取动态 :class 属性
	const dynamicClassRegex =
		/:class\s*=\s*(['"`])((?:[^'"`\\]|\\.|`[^`]*`|'[^']*'|"[^"]*")*?)\1/gis;
	while ((match = dynamicClassRegex.exec(code)) !== null) {
		const value = match[2].trim();
		// 使用 getDynamicClassNames 提取动态类名
		getDynamicClassNames(value).forEach((name) => classNames.add(name));
	}

	return Array.from(classNames);
}

/**
 * 替换属性中的类名
 */
function replaceClassNames(
	attrs: string,
	classNameMap: Map<string, string>,
	targetAttr?: string
): string {
	let result = attrs;

	classNameMap.forEach((safeName, originalName) => {
		const escapedName = escapeRegex(originalName);
		const regex = new RegExp(
			`(?<=^|[\\s'"\`\\[\\{,])${escapedName}(?=[\\s'"\`\\]\\},]|$)`,
			"g"
		);

		if (targetAttr) {
			// 只在指定属性中替换
			const attrMatch = extractAttribute(result, targetAttr);
			if (attrMatch) {
				const newValue = attrMatch.value.replace(regex, safeName);
				if (newValue !== attrMatch.value) {
					const prefix = attrMatch.fullMatch.startsWith(" ") ? " " : "";
					result = result.replace(
						attrMatch.fullMatch,
						`${prefix}${targetAttr}=${attrMatch.quote}${newValue}${attrMatch.quote}`
					);
				}
			}
		} else {
			// 在所有位置替换
			result = result.replace(regex, safeName);
		}
	});

	return result;
}

function parseCode(code: string) {
	let needsDarkImport = false;

	// 解析所有标签
	const tags = parseAllTags(code);

	// 收集所有需要替换的内容
	const replacements: Array<{ start: number; end: number; newTag: string }> = [];

	tags.forEach((tag) => {
		let newAttrs = tag.attributes;
		let modified = false;

		// 1. 提取所有类名
		const allClassNames = getClassNames(`<div${newAttrs}>`);

		// 2. 构建类名转换映射
		const classNameMap = new Map<string, string>();
		const darkClassNameMap = new Map<string, string>();

		allClassNames.forEach((name) => {
			if (!isTailwindClass(name)) return;

			if (name.startsWith("dark:")) {
				// dark: 类名：转换所有特殊字符（包括冒号），用于 :pt
				const safeName = toSafeClassWithDark(name);
				if (safeName !== name) {
					darkClassNameMap.set(name, safeName);
				}
			} else {
				// 非 dark: 类名：用于所有属性
				const safeName = toSafeClass(name);
				if (safeName !== name) {
					classNameMap.set(name, safeName);
				}
			}
		});

		// 3. 替换非 dark: 类名（在所有属性中）
		if (classNameMap.size > 0) {
			const newValue = replaceClassNames(newAttrs, classNameMap);
			if (newValue !== newAttrs) {
				newAttrs = newValue;
				modified = true;
			}
		}

		// 4. 替换 dark: 类名（只在 :pt 属性中）
		if (darkClassNameMap.size > 0) {
			const newValue = replaceClassNames(newAttrs, darkClassNameMap, ":pt");
			if (newValue !== newAttrs) {
				newAttrs = newValue;
				modified = true;
			}
		}

		// 5. 处理 class 和 :class 中的 dark: 类名
		if (!config.isPlugin) {
			const darkClassNames = getClassNamesExcludingPt(`<div${newAttrs}>`).filter((name) =>
				name.startsWith("dark:")
			);

			if (darkClassNames.length > 0) {
				const darkResult = handleDarkMode(newAttrs, darkClassNames);
				if (darkResult.modified) {
					newAttrs = darkResult.attrs;
					modified = true;
					needsDarkImport = true;
				}
			}
		}

		if (modified) {
			replacements.push({
				start: tag.startPos,
				end: tag.endPos,
				newTag: `<${tag.tagName}${newAttrs}${tag.closing}`
			});
		}
	});

	// 应用所有替换（从后往前，避免位置偏移）
	let result = code;
	replacements.reverse().forEach(({ start, end, newTag }) => {
		result = result.substring(0, start) + newTag + result.substring(end);
	});

	// 添加暗黑模式导入
	if (needsDarkImport && result !== code) {
		if (!result.includes("<script")) {
			result += '\n<script lang="ts" setup></script>';
		}
		// 检查 script 标签中是否已经有 __isDark 导入
		if (!result.includes("isDark as __isDark")) {
			result = addScriptContent(result, `import { isDark as __isDark } from "@/.cool";`);
		}
	}

	// 清理空属性
	result = result.replace(/\s+:class=(["'])[\s]*\1/g, "").replace(/\s+class=(["'])[\s]*\1/g, "");

	return result !== code ? result : null;
}

function parseAllTags(code: string): TagInfo[] {
	const tags: TagInfo[] = [];
	let i = 0;

	while (i < code.length) {
		// 查找下一个标签开始
		const tagStart = code.indexOf("<", i);
		if (tagStart === -1) break;

		// 跳过注释
		if (code.substring(tagStart, tagStart + 4) === "<!--") {
			const commentEnd = code.indexOf("-->", tagStart + 4);
			i = commentEnd !== -1 ? commentEnd + 3 : code.length;
			continue;
		}

		// 跳过结束标签
		if (code[tagStart + 1] === "/") {
			const tagEnd = code.indexOf(">", tagStart + 2);
			i = tagEnd !== -1 ? tagEnd + 1 : code.length;
			continue;
		}

		// 提取标签名
		const tagNameMatch = code.substring(tagStart + 1).match(/^([a-zA-Z][\w-]*)/);
		if (!tagNameMatch) {
			i = tagStart + 1;
			continue;
		}

		const tagName = tagNameMatch[1];
		const tagNameEnd = tagStart + 1 + tagName.length;

		// 查找标签结束
		let pos = tagNameEnd;
		let inString = false;
		let stringChar = "";
		let depth = 0;

		while (pos < code.length) {
			const char = code[pos];

			if (!inString) {
				if (char === '"' || char === "'" || char === "`") {
					inString = true;
					stringChar = char;
				} else if (char === "{") {
					depth++;
				} else if (char === "}") {
					depth--;
				} else if (char === ">" && depth === 0) {
					// 找到标签结束
					let attributes = code.substring(tagNameEnd, pos);
					const isSelfClosing = code[pos - 1] === "/";

					// 如果是自闭合标签，从 attributes 中移除末尾的空格和 /
					if (isSelfClosing) {
						attributes = attributes.replace(/\s*\/$/, "");
					}

					const closing = isSelfClosing ? " />" : ">";
					const fullTag = code.substring(tagStart, pos + 1);

					tags.push({
						fullTag,
						tagName,
						attributes,
						closing,
						startPos: tagStart,
						endPos: pos + 1
					});

					i = pos + 1;
					break;
				}
			} else {
				if (char === stringChar && code[pos - 1] !== "\\") {
					inString = false;
					stringChar = "";
				}
			}

			pos++;
		}

		if (pos >= code.length) {
			i = code.length;
		}
	}

	return tags;
}

function handleDarkMode(
	attrs: string,
	darkClassNames: string[]
): { attrs: string; modified: boolean } {
	let newAttrs = attrs;
	let modified = false;

	// 过滤掉包含空格的字符串（不是单个类名），并转换为安全类名
	const validDarkClassNames = darkClassNames.filter((name) => !name.includes(" "));
	const safeDarkClassNames = validDarkClassNames.map((name) => toSafeClass(name));

	// 从静态 class 中移除 dark: 类名
	const staticClassMatch = extractAttribute(newAttrs, "class");
	if (staticClassMatch) {
		let newClassValue = staticClassMatch.value;

		validDarkClassNames.forEach((originalName) => {
			const escapedName = escapeRegex(originalName);
			const regex = new RegExp(`(?:^|\\s)(${escapedName})(?=\\s|$)`, "g");
			newClassValue = newClassValue.replace(regex, (match) =>
				match.startsWith(" ") ? " " : ""
			);
		});

		newClassValue = newClassValue.replace(/\s+/g, " ").trim();

		if (newClassValue !== staticClassMatch.value) {
			const prefix = staticClassMatch.fullMatch.startsWith(" ") ? " " : "";
			newAttrs = newAttrs.replace(
				staticClassMatch.fullMatch,
				newClassValue
					? `${prefix}class=${staticClassMatch.quote}${newClassValue}${staticClassMatch.quote}`
					: ""
			);
			modified = true;
		}
	}

	// 生成暗黑模式对象
	const darkClassObject = safeDarkClassNames.map((name) => `'${name}': __isDark`).join(", ");

	// 处理动态 :class
	const dynamicClassMatch = extractAttribute(newAttrs, ":class");

	if (!dynamicClassMatch) {
		newAttrs += ` :class="{${darkClassObject}}"`;
		modified = true;
	} else {
		let newClassValue = dynamicClassMatch.value.trim();

		// 删除 dark: 类名
		validDarkClassNames.forEach((originalName, index) => {
			const safeName = safeDarkClassNames[index];
			const escapedOriginal = escapeRegex(originalName);
			const escapedSafe = escapeRegex(safeName);

			// 删除键值对
			newClassValue = newClassValue
				.replace(new RegExp(`(['"\`])${escapedOriginal}\\1\\s*:\\s*[^,}\\]]+`, "g"), "")
				.replace(new RegExp(`(['"\`])${escapedSafe}\\1\\s*:\\s*[^,}\\]]+`, "g"), "");

			// 删除字符串中的类名
			newClassValue = newClassValue.replace(
				/(['"`])([^'"`]+)\1/g,
				(match, quote, content) => {
					if (!content.includes(originalName) && !content.includes(safeName)) {
						return match;
					}

					let newContent = content
						.replace(new RegExp(`\\b${escapedOriginal}\\b`, "g"), "")
						.replace(new RegExp(`(?:^|\\s)${escapedSafe}(?=\\s|$)`, "g"), "")
						.replace(/\s+/g, " ")
						.trim();

					return newContent ? `${quote}${newContent}${quote}` : "";
				}
			);
		});

		// 清理多余的逗号和空格
		newClassValue = newClassValue
			.replace(/['"`]['"`]/g, "")
			.replace(/,\s*,+/g, ",")
			.replace(/\[\s*,+/g, "[")
			.replace(/,+\s*\]/g, "]")
			.replace(/\{\s*,+/g, "{")
			.replace(/,+\s*\}/g, "}")
			.replace(/\s+/g, " ");

		// 合并暗黑模式对象
		if (newClassValue.startsWith("{") && newClassValue.endsWith("}")) {
			const inner = newClassValue.slice(1, -1).trim();
			newClassValue = inner ? `{${darkClassObject}, ${inner}}` : `{${darkClassObject}}`;
		} else if (newClassValue.startsWith("[") && newClassValue.endsWith("]")) {
			newClassValue = `[{${darkClassObject}}, ${newClassValue.slice(1)}`;
		} else {
			newClassValue = `[{${darkClassObject}}, ${newClassValue}]`;
		}

		const prefix = dynamicClassMatch.fullMatch.startsWith(" ") ? " " : "";
		newAttrs = newAttrs.replace(
			dynamicClassMatch.fullMatch,
			`${prefix}:class=${dynamicClassMatch.quote}${newClassValue}${dynamicClassMatch.quote}`
		);
		modified = true;
	}

	return { attrs: newAttrs, modified };
}

function extractAttribute(
	attrs: string,
	attrName: string
): {
	fullMatch: string;
	value: string;
	quote: string;
} | null {
	// Match attribute name with space before it (or start of string) to avoid matching :class when looking for class
	const regex = new RegExp(`(?:^|\\s)(${escapeRegex(attrName)})=`, "g");
	const match = regex.exec(attrs);

	if (!match) return null;

	const startPos = match.index + match[0].length;
	if (startPos >= attrs.length) return null;

	const quote = attrs[startPos];
	if (quote !== '"' && quote !== "'" && quote !== "`") return null;

	// 查找匹配的结束引号
	let pos = startPos + 1;
	let depth = 0;
	let inString = false;
	let stringChar = "";

	while (pos < attrs.length) {
		const char = attrs[pos];

		if (char === "\\") {
			pos += 2;
			continue;
		}

		if (!inString) {
			if ((char === '"' || char === "'" || char === "`") && char !== quote) {
				inString = true;
				stringChar = char;
			} else if (char === "{" || char === "[" || char === "(") {
				depth++;
			} else if (char === "}" || char === "]" || char === ")") {
				depth--;
			} else if (char === quote && depth === 0) {
				const value = attrs.substring(startPos + 1, pos);
				// Include the space/start in fullMatch
				const fullMatch = attrs.substring(match.index, pos + 1);
				return { fullMatch, value, quote };
			}
		} else {
			if (char === stringChar && attrs[pos - 1] !== "\\") {
				inString = false;
				stringChar = "";
			}
		}

		pos++;
	}

	return null;
}

function escapeRegex(str: string): string {
	return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

// 测试函数
function test() {
	// 设置为非 web 平台以测试类名转换
	config.utsPlatform = "app";

	const html = `
<template>
	<!-- 1. 无 class 属性 -->
	1<view>
    <view class="p-4 border border-solid border-surface-200 dark:!border-surface-600">
      </view>
    </view>
	
	<!-- 2. 静态 class -->
	2<text class="text-lg font-bold">静态类名</text>
	
	<!-- 3. 静态 class 带 dark: -->
	3<text class="text-lg dark:text-red-500">静态带暗黑</text>
	
	<!-- 4. 静态 class 带 !important -->
	4<text class="!text-primary-500 font-bold">带 important</text>
	
	<!-- 5. 静态 class 带 dark:! -->
	5<text class="text-base dark:!text-surface-50">暗黑 important</text>
	
	<!-- 6. 动态 :class 对象形式 -->
	6<text :class="{ 'text-red-500': isActive }">动态对象</text>
	
	<!-- 7. 动态 :class 数组形式 -->
	7<text :class="['text-lg', 'font-bold']">动态数组</text>
	
	<!-- 8. 动态 :class 三元表达式 -->
	8<text :class="isActive ? 'text-red-500' : 'text-blue-500'">三元表达式</text>
	
	<!-- 9. 动态 :class 模板字符串 -->
	9<text :class="\`text-lg \${isActive ? 'text-red-500' : 'text-blue-500'}\`">模板字符串</text>
	
	<!-- 10. 动态 :class 函数调用 -->
	10<text :class="parseClass({ '!bg-red-50': hoverable })">函数调用</text>
	
	<!-- 11. 静态 + 动态 class -->
	11<text class="text-lg" :class="{ 'font-bold': isActive }">静态+动态</text>
	
	<!-- 12. 静态 dark: + 动态 :class -->
	12<text class="text-lg dark:text-red-500" :class="{ 'font-bold': isActive }">静态暗黑+动态</text>
	
	<!-- 13. hover-class 静态 -->
	13<text hover-class="bg-gray-100">hover 静态</text>
	
	<!-- 14. :hover-class 动态 -->
	14<text :hover-class="isActive ? 'bg-red-100' : 'bg-blue-100'">hover 动态</text>
	
	<!-- 15. :pt 属性单个 className -->
	15<text :pt="{ className: '!text-green-50 dark:!text-red-500' }">pt 单个</text>
	
	<!-- 16. :pt 属性嵌套 className -->
	16<text :pt="{
		title: { className: '!text-primary-500' },
		icon: { className: '!text-primary-400' }
	}">pt 嵌套</text>
	
	<!-- 17. :pt 属性函数调用 -->
	17<text :pt="{
		className: parseClass({ '!text-green-100': hoverable })
	}">pt 函数</text>
	
	<!-- 18. :pt 属性模板字符串 -->
	18<text :pt="{
		className: \`text-green-300 \${isActive ? 'font-bold' : 'font-normal'}\`
	}">pt 模板</text>
	
	<!-- 19. 多个 dark: 类名 -->
	19<text class="text-lg dark:text-red-500 dark:bg-gray-900">多个暗黑</text>
	
	<!-- 20. 混合 dark: 和 !important -->
	20<text class="!text-lg dark:!text-red-500 dark:bg-gray-900">暗黑+important</text>
	
	<!-- 21. 动态 :class 对象带 dark: -->
	21<text :class="{ 'dark:text-red-500': isActive }">动态对象暗黑</text>
	
	<!-- 22. 动态 :class 数组混合 -->
	22<text :class="[
		'text-lg',
		{ 'text-red-500': isActive },
		isActive ? 'font-bold' : 'font-normal'
	]">动态数组混合</text>
	
	<!-- 23. 复杂嵌套表达式 -->
	23<text :class="{
		'text-red-500': isActive && isEnabled,
		'text-blue-500': !isActive || isDisabled
	}">复杂嵌套</text>
	
	<!-- 24. 带 v-if 的元素 -->
	24<text class="text-lg dark:text-red-500" v-if="show">带 v-if</text>
	
	<!-- 25. 带 v-for 的元素 -->
	25<text class="text-lg dark:text-red-500" v-for="item in items" :key="item.id">带 v-for</text>
	
	<!-- 26. 自闭合标签 -->
	26<text class="text-lg dark:text-red-500" />
	
	<!-- 27. 多行 class 属性 -->
	27<text class="
		text-lg
		font-bold
		dark:text-red-500
		dark:bg-gray-900
	">多行 class</text>
	
	<!-- 28. 空 class -->
	28<text class="">空 class</text>
	
	<!-- 29. 只有空格的 class -->
	29<text class="   ">空格 class</text>
	
	<!-- 30. 非 text 标签 -->
	30<view class="flex items-center dark:bg-gray-900">非 text 标签</view>
	
	<!-- 31. 组件标签带 dark: -->
	31<cl-button class="!text-primary-500 dark:!text-surface-50">组件标签</cl-button>
	
	<!-- 32. 混合所有特性 -->
	32<text 
		class="text-lg font-bold dark:text-red-500 dark:!bg-gray-900"
		:class="[{ 'underline': isActive, 'dark:text-green-500': true, }, 'dark:!text-red-900 dark:!bg-red']"
		hover-class="bg-gray-100"
		:hover-class="isActive ? 'bg-red-100' : 'bg-blue-100'"
		:pt="{
			className: '!text-green-50 dark:text-blue-500',
			title: { className: 'font-bold dark:!text-yellow-500' }
		}"
		v-if="5 > 1"
	>混合所有特性</text>
</template>
`;

	console.log(parseCode(html));
}

// test();
