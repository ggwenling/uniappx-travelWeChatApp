(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('fs'), require('path'), require('prettier'), require('lodash'), require('postcss-value-parser'), require('glob'), require('util')) :
    typeof define === 'function' && define.amd ? define(['exports', 'fs', 'path', 'prettier', 'lodash', 'postcss-value-parser', 'glob', 'util'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.index = {}, global.fs, global.path, global.prettier, global.lodash, global.valueParser, global.glob, global.util));
})(this, (function (exports, fs, path, prettier, lodash, valueParser, glob, util) { 'use strict';

    const config = {
        reqUrl: "",
        tailwind: {
            enable: true,
            remUnit: 16,
            remPrecision: 6,
            rpxRatio: 2,
            darkTextClass: "dark:text-surface-50",
        },
        isPlugin: false,
        utsPlatform: "web",
    };
    /**
     * 特殊字符映射表
     */
    const SAFE_CHAR_MAP = {
        "[": "-bracket-start-",
        "]": "-bracket-end-",
        "(": "-paren-start-",
        ")": "-paren-end-",
        "{": "-brace-start-",
        "}": "-brace-end-",
        $: "-dollar-",
        "#": "-hash-",
        "!": "-important-",
        "/": "-slash-",
        ":": "-colon-",
    };

    // 根目录
    function rootDir(path$1) {
        return path.join(process.env.UNI_INPUT_DIR, path$1).replace(/\\/g, "/");
    }
    // 读取文件
    function readFile(path, json) {
        try {
            const content = fs.readFileSync(path, "utf8");
            return json ? JSON.parse(removeJsonComments(content)) : content;
        }
        catch (err) { }
        return "";
    }
    // 安全地移除JSON中的注释
    function removeJsonComments(content) {
        let result = "";
        let inString = false;
        let stringChar = "";
        let escaped = false;
        let i = 0;
        while (i < content.length) {
            const char = content[i];
            const nextChar = content[i + 1];
            // 处理字符串状态
            if (!inString && (char === '"' || char === "'")) {
                inString = true;
                stringChar = char;
                result += char;
            }
            else if (inString && char === stringChar && !escaped) {
                inString = false;
                stringChar = "";
                result += char;
            }
            else if (inString) {
                // 在字符串内，直接添加字符
                result += char;
                escaped = char === "\\" && !escaped;
            }
            else {
                // 不在字符串内，检查注释
                if (char === "/" && nextChar === "/") {
                    // 单行注释，跳过到行尾
                    while (i < content.length && content[i] !== "\n") {
                        i++;
                    }
                    if (i < content.length) {
                        result += content[i]; // 保留换行符
                    }
                }
                else if (char === "/" && nextChar === "*") {
                    // 多行注释，跳过到 */
                    i += 2;
                    while (i < content.length - 1) {
                        if (content[i] === "*" && content[i + 1] === "/") {
                            i += 2;
                            break;
                        }
                        i++;
                    }
                    continue;
                }
                else {
                    result += char;
                    escaped = false;
                }
            }
            i++;
        }
        return result;
    }
    // 写入文件
    function writeFile(path, data) {
        try {
            return fs.writeFileSync(path, data);
        }
        catch (err) { }
        return "";
    }
    function error(message) {
        console.log("\x1B[31m%s\x1B[0m", message);
    }
    // 获取函数声明的位置
    function getCodeIndex(value, code, isAfter) {
        const match = value.exec(code);
        if (!match) {
            return -1;
        }
        return isAfter ? match.index + match[0].length : match.index;
    }

    const filePath = rootDir("./config/proxy.ts");
    function getProxyTarget(proxy) {
        const code = readFile(filePath);
        const regex = /const\s+value\s*=\s*['"]([^'"]+)['"]/;
        const match = code.match(regex);
        if (match) {
            const value = match[1];
            try {
                const { target, rewrite } = proxy[`/${value}/`];
                return target + rewrite(`/${value}`);
            }
            catch (err) {
                error(`[cool-proxy] Error：${value} → ` + filePath);
                return "";
            }
        }
    }

    /**
     * 获取动态类名
     */
    const getDynamicClassNames = (value) => {
        const names = new Set();
        // 匹配函数调用中的对象参数（如 parseClass({'!bg-surface-50': hoverable})）
        const functionCallRegex = /\w+\s*\(\s*\{([^}]*)\}\s*\)/gs;
        let funcMatch;
        while ((funcMatch = functionCallRegex.exec(value)) !== null) {
            const objContent = funcMatch[1];
            // 提取对象中的键
            const keyRegex = /['"](.*?)['"]\s*:/gs;
            let keyMatch;
            while ((keyMatch = keyRegex.exec(objContent)) !== null) {
                keyMatch[1].trim() && names.add(keyMatch[1]);
            }
        }
        // 匹配对象键（如 { 'text-a': 1 }）- 优化版本，避免跨行错误匹配
        const objKeyRegex = /[{,]\s*['"](.*?)['"]\s*:/gs;
        let objKeyMatch;
        while ((objKeyMatch = objKeyRegex.exec(value)) !== null) {
            const className = objKeyMatch[1].trim();
            // 确保是有效的CSS类名，避免匹配到错误内容
            if (className && !className.includes("\n") && !className.includes("\t")) {
                names.add(className);
            }
        }
        // 匹配数组中的字符串元素（如 'text-center'）- 优化版本
        const arrayStringRegex = /(?:^|[,\[\s])\s*['"](.*?)['"]/gs;
        let arrayMatch;
        while ((arrayMatch = arrayStringRegex.exec(value)) !== null) {
            const className = arrayMatch[1].trim();
            // 确保是有效的CSS类名
            if (className && !className.includes("\n") && !className.includes("\t")) {
                names.add(className);
            }
        }
        // 匹配三元表达式中的字符串（如 'dark' 和 'light'）
        const ternaryRegex = /(\?|:)\s*['"](.*?)['"]/gs;
        let ternaryMatch;
        while ((ternaryMatch = ternaryRegex.exec(value)) !== null) {
            ternaryMatch[2].trim() && names.add(ternaryMatch[2]);
        }
        // 匹配反引号模板字符串 - 改进版本
        const templateRegex = /`([^`]*)`/gs;
        let templateMatch;
        while ((templateMatch = templateRegex.exec(value)) !== null) {
            const templateContent = templateMatch[1];
            // 提取模板字符串中的普通文本部分（排除 ${} 表达式）
            const textParts = templateContent.split(/\$\{[^}]*\}/);
            textParts.forEach((part) => {
                part
                    .trim()
                    .split(/\s+/)
                    .forEach((className) => {
                    className.trim() && names.add(className.trim());
                });
            });
            // 提取模板字符串中 ${} 表达式内的字符串
            const expressionRegex = /\$\{([^}]*)\}/gs;
            let expressionMatch;
            while ((expressionMatch = expressionRegex.exec(templateContent)) !== null) {
                const expression = expressionMatch[1];
                // 递归处理表达式中的动态类名
                getDynamicClassNames(expression).forEach((name) => names.add(name));
            }
        }
        // 处理混合字符串（模板字符串 + 普通文本），如 "`text-red-900` text-red-1000"
        const mixedStringRegex = /`[^`]*`\s+([a-zA-Z0-9\-_\s]+)/g;
        let mixedMatch;
        while ((mixedMatch = mixedStringRegex.exec(value)) !== null) {
            const additionalClasses = mixedMatch[1].trim().split(/\s+/);
            additionalClasses.forEach((className) => {
                className.trim() && names.add(className.trim());
            });
        }
        // 处理普通字符串，多个类名用空格分割
        const stringRegex = /['"]([\w\s\-!:\/]+?)['"]/gs;
        let stringMatch;
        while ((stringMatch = stringRegex.exec(value)) !== null) {
            const classNames = stringMatch[1].trim().split(/\s+/);
            classNames.forEach((className) => {
                className.trim() && names.add(className.trim());
            });
        }
        return Array.from(names);
    };
    /**
     * 获取类名
     */
    function getClassNames(code) {
        // 修改正则表达式以支持多行匹配，避免内层引号冲突
        const classRegex = /(?:class|:class|:pt|:hover-class)\s*=\s*(['"`])((?:[^'"`\\]|\\.|`[^`]*`|'[^']*'|"[^"]*")*?)\1/gis;
        const classNames = new Set();
        let match;
        while ((match = classRegex.exec(code)) !== null) {
            const attribute = match[0].split("=")[0].trim();
            const isStaticClass = attribute === "class" || attribute === "hover-class";
            const isPtAttribute = attribute.includes("pt");
            const value = match[2].trim();
            if (isStaticClass) {
                // 处理静态 class 和 hover-class
                value.split(/\s+/).forEach((name) => name && classNames.add(name));
            }
            else if (isPtAttribute) {
                // 处理 :pt 属性中的 className
                parseClasNameFromPt(value, classNames);
            }
            else {
                // 处理动态 :class 和 :hover-class
                getDynamicClassNames(value).forEach((name) => classNames.add(name));
            }
        }
        return Array.from(classNames);
    }
    /**
     * 从 :pt 属性中解析 className
     */
    function parseClasNameFromPt(value, classNames) {
        // 递归查找所有 className 属性
        const classNameRegex = /className\s*:\s*/g;
        let match;
        while ((match = classNameRegex.exec(value)) !== null) {
            const startPos = match.index + match[0].length;
            const classNameValue = extractComplexValue(value, startPos);
            if (classNameValue) {
                // 如果是字符串字面量
                if (classNameValue.startsWith('"') ||
                    classNameValue.startsWith("'") ||
                    classNameValue.startsWith("`")) {
                    if (classNameValue.startsWith("`")) {
                        // 处理模板字符串
                        getDynamicClassNames(classNameValue).forEach((name) => classNames.add(name));
                    }
                    else {
                        // 处理普通字符串
                        const strMatch = classNameValue.match(/['"](.*?)['"]/);
                        if (strMatch) {
                            strMatch[1]
                                .split(/\s+/)
                                .forEach((name) => name && classNames.add(name));
                        }
                    }
                }
                else {
                    // 处理动态值（如函数调用、对象等）
                    getDynamicClassNames(classNameValue).forEach((name) => classNames.add(name));
                }
            }
        }
    }
    /**
     * 提取复杂值（支持嵌套引号和括号）
     */
    function extractComplexValue(text, startPos) {
        let pos = startPos;
        let depth = 0;
        let inString = false;
        let stringChar = "";
        let result = "";
        // 跳过开头的空白字符
        while (pos < text.length && /\s/.test(text[pos])) {
            pos++;
        }
        while (pos < text.length) {
            const char = text[pos];
            if (!inString) {
                if (char === '"' || char === "'" || char === "`") {
                    inString = true;
                    stringChar = char;
                    result += char;
                }
                else if (char === "{" || char === "(" || char === "[") {
                    depth++;
                    result += char;
                }
                else if (char === "}" || char === ")" || char === "]") {
                    if (depth === 0 && char === "}") {
                        // 遇到顶层的 } 时结束
                        break;
                    }
                    depth--;
                    result += char;
                }
                else if (char === "," && depth === 0) {
                    // 遇到顶层的逗号时结束
                    break;
                }
                else if (char === "\n" && depth === 0 && result.trim() !== "") {
                    // 如果遇到换行且不在嵌套结构中，且已有内容，则结束
                    break;
                }
                else {
                    result += char;
                }
            }
            else {
                result += char;
                if (char === stringChar && text[pos - 1] !== "\\") {
                    inString = false;
                    stringChar = "";
                    // 如果字符串结束且depth为0，检查是否应该结束
                    if (depth === 0) {
                        // 看看下一个非空白字符是什么
                        let nextPos = pos + 1;
                        while (nextPos < text.length && /\s/.test(text[nextPos])) {
                            nextPos++;
                        }
                        if (nextPos < text.length &&
                            (text[nextPos] === "," || text[nextPos] === "}")) {
                            // 如果下一个字符是逗号或右括号，则结束
                            break;
                        }
                    }
                }
            }
            pos++;
        }
        return result.trim() || null;
    }
    /**
     * 添加 script 标签内容
     */
    function addScriptContent(code, content) {
        const scriptMatch = /<script\b[^>]*>([\s\S]*?)<\/script>/g.exec(code);
        if (!scriptMatch) {
            return code;
        }
        const scriptContent = scriptMatch[1];
        const scriptStartIndex = scriptMatch.index + scriptMatch[0].indexOf(">") + 1;
        const scriptEndIndex = scriptStartIndex + scriptContent.length;
        return (code.substring(0, scriptStartIndex) +
            "\n" +
            content +
            "\n" +
            scriptContent.trim() +
            code.substring(scriptEndIndex));
    }
    /**
     * 判断是否为 Tailwind 类名
     */
    function isTailwindClass(className) {
        const prefixes = [
            // 布局
            "container",
            "flex",
            "grid",
            "block",
            "inline",
            "hidden",
            "visible",
            // 间距
            "p-",
            "px-",
            "py-",
            "pt-",
            "pr-",
            "pb-",
            "pl-",
            "m-",
            "mx-",
            "my-",
            "mt-",
            "mr-",
            "mb-",
            "ml-",
            "space-",
            "gap-",
            // 尺寸
            "w-",
            "h-",
            "min-w-",
            "max-w-",
            "min-h-",
            "max-h-",
            // 颜色
            "bg-",
            "text-",
            "border-",
            "ring-",
            "shadow-",
            // 边框
            "border",
            "rounded",
            "ring",
            // 字体
            "font-",
            "text-",
            "leading-",
            "tracking-",
            "antialiased",
            // 定位
            "absolute",
            "relative",
            "fixed",
            "sticky",
            "static",
            "top-",
            "right-",
            "bottom-",
            "left-",
            "inset-",
            "z-",
            // 变换
            "transform",
            "translate-",
            "rotate-",
            "scale-",
            "skew-",
            // 过渡
            "transition",
            "duration-",
            "ease-",
            "delay-",
            // 交互
            "cursor-",
            "select-",
            "pointer-events-",
            // 溢出
            "overflow-",
            "truncate",
            // 滚动
            "scroll-",
            // 伪类和响应式
            "hover:",
            "focus:",
            "active:",
            "disabled:",
            "group-hover:",
        ];
        const statePrefixes = [
            "dark:",
            "dark:!",
            "light:",
            "sm:",
            "md:",
            "lg:",
            "xl:",
            "2xl:",
        ];
        if (className.startsWith("!") && !className.includes("!=")) {
            return true;
        }
        for (const prefix of prefixes) {
            if (className.startsWith(prefix)) {
                return true;
            }
            for (const statePrefix of statePrefixes) {
                if (className.startsWith(statePrefix + prefix)) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * 获取 Tailwind 颜色
     * @returns Tailwind 颜色
     */
    function getTailwindColor() {
        const config = readFile(rootDir("tailwind.config.ts"));
        if (!config) {
            return null;
        }
        try {
            // 从配置文件中动态提取主色和表面色
            const colorResult = {};
            // 提取 getPrimary 调用中的颜色名称
            const primaryMatch = config.match(/getPrimary\(["']([^"']+)["']\)/);
            const primaryColorName = primaryMatch?.[1];
            // 提取 getSurface 调用中的颜色名称
            const surfaceMatch = config.match(/getSurface\(["']([^"']+)["']\)/);
            const surfaceColorName = surfaceMatch?.[1];
            if (primaryColorName) {
                // 提取 PRIMARY_COLOR_PALETTES 中对应的调色板
                const primaryPaletteMatch = config.match(new RegExp(`{\\s*name:\\s*["']${primaryColorName}["'],\\s*palette:\\s*({[^}]+})`, "s"));
                if (primaryPaletteMatch) {
                    // 解析调色板对象
                    const paletteStr = primaryPaletteMatch[1];
                    const paletteEntries = paletteStr.match(/(\d+):\s*["']([^"']+)["']/g);
                    if (paletteEntries) {
                        paletteEntries.forEach((entry) => {
                            const match = entry.match(/(\d+):\s*["']([^"']+)["']/);
                            if (match) {
                                const [, key, value] = match;
                                colorResult[`primary-${key}`] = value;
                            }
                        });
                    }
                }
            }
            if (surfaceColorName) {
                // 提取 SURFACE_PALETTES 中对应的调色板
                const surfacePaletteMatch = config.match(new RegExp(`{\\s*name:\\s*["']${surfaceColorName}["'],\\s*palette:\\s*({[^}]+})`, "s"));
                if (surfacePaletteMatch) {
                    // 解析调色板对象
                    const paletteStr = surfacePaletteMatch[1];
                    const paletteEntries = paletteStr.match(/(\d+):\s*["']([^"']+)["']/g);
                    if (paletteEntries) {
                        paletteEntries.forEach((entry) => {
                            const match = entry.match(/(\d+):\s*["']([^"']+)["']/);
                            if (match) {
                                const [, key, value] = match;
                                // 0 对应 surface，其他对应 surface-*
                                const colorKey = key === "0" ? "surface" : `surface-${key}`;
                                colorResult[colorKey] = value;
                            }
                        });
                    }
                }
            }
            return colorResult;
        }
        catch (error) {
            return null;
        }
    }
    /**
     * 转换类名中的特殊字符为安全字符
     */
    function toSafeClass(className) {
        if (config.utsPlatform == "web") {
            return className;
        }
        if (className.includes(":host")) {
            return className;
        }
        // 如果是表达式,则不进行转换
        if (["!=", "!==", "?", ":", "="].includes(className)) {
            return className;
        }
        let safeClassName = className;
        // 移除 dark: 前缀（在转换特殊字符之前）
        if (safeClassName.startsWith("dark:")) {
            safeClassName = safeClassName.substring(5); // 移除 "dark:"
        }
        // 移除转义字符
        if (safeClassName.includes("\\")) {
            safeClassName = safeClassName.replace(/\\/g, "");
        }
        // 处理暗黑模式
        if (safeClassName.includes(":is")) {
            if (safeClassName.includes(":is(.dark *)")) {
                safeClassName = safeClassName.replace(/:is\(.dark \*\)/g, "");
                if (safeClassName.startsWith(".dark:")) {
                    const className = safeClassName.replace(/^\.dark:/, ".dark:");
                    safeClassName = `${className}`;
                }
            }
        }
        // 替换特殊字符
        for (const [char, replacement] of Object.entries(SAFE_CHAR_MAP)) {
            const regex = new RegExp("\\" + char, "g");
            if (regex.test(safeClassName)) {
                safeClassName = safeClassName.replace(regex, replacement);
            }
        }
        return safeClassName;
    }
    /**
     * 转换 RGB 为 RGBA 格式
     */
    function rgbToRgba(rgbValue) {
        const match = rgbValue.match(/rgb\(([\d\s]+)\/\s*([\d.]+)\)/);
        if (!match)
            return rgbValue;
        const [, rgb, alpha] = match;
        const [r, g, b] = rgb.split(/\s+/);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }
    /**
     * rem 转 px
     * @param remValue rem 值
     * @returns
     */
    function remToPx(remValue) {
        const { remUnit = 14, remPrecision = 6 } = config.tailwind;
        const precision = (remValue.split(".")[1] || "").length;
        const pxValue = (parseFloat(remValue) * remUnit)
            .toFixed(precision || remPrecision)
            .replace(/\.?0+$/, "");
        return `${pxValue}px`;
    }

    function cssPlugin() {
        return {
            name: "vite-cool-unix-tailwind-css",
            enforce: "pre",
            config() {
                return {
                    css: {
                        postcss: {
                            plugins: [
                                {
                                    postcssPlugin: "vite-cool-uniappx-class-mapping",
                                    prepare() {
                                        return {
                                            // 处理选择器规则
                                            Rule(rule) {
                                                if ([
                                                    ".button-hover",
                                                    ":deep(",
                                                    "&::",
                                                    "uni-",
                                                    ".uni-"
                                                ].some((e) => rule.selector.includes(e))) {
                                                    return;
                                                }
                                                // 转换选择器为安全的类名格式
                                                rule.selector = toSafeClass(rule.selector);
                                            },
                                            // 处理声明规则
                                            Declaration(decl) {
                                                const className = decl.parent.selector || "";
                                                if (!decl.parent._twValues) {
                                                    decl.parent._twValues = {};
                                                }
                                                // 处理 Tailwind 自定义属性
                                                if (decl.prop.includes("--tw-")) {
                                                    decl.parent._twValues[decl.prop] =
                                                        decl.value.includes("rem")
                                                            ? remToPx(decl.value)
                                                            : decl.value;
                                                    decl.remove();
                                                    return;
                                                }
                                                // 转换 RGB 颜色为 RGBA 格式
                                                if (decl.value.includes("rgb(") &&
                                                    decl.value.includes("/")) {
                                                    decl.value = rgbToRgba(decl.value);
                                                }
                                                // 处理文本大小相关样式
                                                if (decl.value.includes("px") &&
                                                    decl.prop == "color" &&
                                                    className.includes("text-")) {
                                                    decl.prop = "font-size";
                                                }
                                                // 删除不支持的属性
                                                if (["filter"].includes(decl.prop)) {
                                                    decl.remove();
                                                    return;
                                                }
                                                // 处理 flex-1
                                                if (decl.prop == "flex") {
                                                    if (decl.value.startsWith("1")) {
                                                        decl.value = "1";
                                                    }
                                                }
                                                // 处理 vertical-align 属性
                                                if (decl.prop == "vertical-align") {
                                                    decl.remove();
                                                }
                                                // 处理 visibility 属性
                                                if (decl.prop == "visibility") {
                                                    decl.remove();
                                                }
                                                // 处理 sticky 属性
                                                if (className == ".sticky") {
                                                    if (decl.prop == "position" ||
                                                        decl.value == "sticky") {
                                                        decl.remove();
                                                    }
                                                }
                                                // 解析声明值
                                                const parsed = valueParser(decl.value);
                                                let hasChanges = false;
                                                // 遍历并处理声明值中的节点
                                                parsed.walk((node) => {
                                                    // 处理单位转换(rem -> px)
                                                    if (node.type === "word") {
                                                        const unit = valueParser.unit(node.value);
                                                        if (typeof unit != "boolean") {
                                                            if (unit?.unit === "rem") {
                                                                node.value = remToPx(unit.number);
                                                                hasChanges = true;
                                                            }
                                                        }
                                                    }
                                                    // 处理 CSS 变量
                                                    if (node.type === "function" &&
                                                        node.value === "var") {
                                                        const twKey = node.nodes[0]?.value;
                                                        // 替换 Tailwind 变量为实际值
                                                        if (twKey?.startsWith("--tw-")) {
                                                            if (decl.parent._twValues) {
                                                                node.type = "word";
                                                                node.value =
                                                                    decl.parent._twValues[twKey] ||
                                                                        "none";
                                                                hasChanges = true;
                                                            }
                                                        }
                                                    }
                                                });
                                                // 更新声明值
                                                if (hasChanges) {
                                                    decl.value = parsed.toString();
                                                }
                                                // 移除 Tailwind 生成的无效 none 变换
                                                const nones = [
                                                    "translate(none, none)",
                                                    "rotate(none)",
                                                    "skewX(none)",
                                                    "skewY(none)",
                                                    "scaleX(none)",
                                                    "scaleY(none)"
                                                ];
                                                if (decl.value) {
                                                    nones.forEach((noneStr) => {
                                                        decl.value = decl.value.replace(noneStr, "");
                                                        if (!decl.value || !decl.value.trim()) {
                                                            decl.value = "none";
                                                        }
                                                    });
                                                }
                                            }
                                        };
                                    }
                                }
                            ]
                        }
                    }
                };
            }
        };
    }

    /**
     * class 类名转换
     * @returns
     */
    function classPlugin() {
        return {
            name: "vite-cool-unix-tailwind-class",
            enforce: "pre",
            async transform(code, id) {
                // 判断是否为 uvue 文件
                if (id.endsWith(".uvue") || id.includes(".uvue?type=page")) {
                    // 避免影响到其他模块/插件
                    if (id.includes("uni_modules/") && !id.includes("uni_modules/cool-")) {
                        return null;
                    }
                    // 解析代码
                    code = parseCode(code) ?? "";
                    if (code) {
                        return {
                            code,
                            map: { mappings: "" }
                        };
                    }
                }
                return null;
            }
        };
    }
    /**
     * 转换类名中的特殊字符为安全字符（包括 dark: 中的冒号）
     */
    function toSafeClassWithDark(className) {
        if (config.utsPlatform === "web" || className.includes(":host")) {
            return className;
        }
        // 如果是表达式,则不进行转换
        if (["!=", "!==", "?", ":", "="].includes(className)) {
            return className;
        }
        let result = className.replace(/\\/g, ""); // 移除转义字符
        // 替换特殊字符（包括 dark: 中的冒号）
        for (const [char, replacement] of Object.entries(SAFE_CHAR_MAP)) {
            if (result.includes(char)) {
                result = result.replace(new RegExp("\\" + char, "g"), replacement);
            }
        }
        return result;
    }
    /**
     * 获取 class 和 :class 中的类名（不包括 :pt）
     */
    function getClassNamesExcludingPt(code) {
        const classNames = new Set();
        // 1. 提取静态 class 属性
        const staticClassRegex = /(?:^|\s)class\s*=\s*(['"`])([^'"`]*?)\1/gi;
        let match;
        while ((match = staticClassRegex.exec(code)) !== null) {
            const value = match[2].trim();
            value.split(/\s+/).forEach((name) => name && classNames.add(name));
        }
        // 2. 提取动态 :class 属性
        const dynamicClassRegex = /:class\s*=\s*(['"`])((?:[^'"`\\]|\\.|`[^`]*`|'[^']*'|"[^"]*")*?)\1/gis;
        while ((match = dynamicClassRegex.exec(code)) !== null) {
            const value = match[2].trim();
            // 使用 getDynamicClassNames 提取动态类名
            getDynamicClassNames(value).forEach((name) => classNames.add(name));
        }
        return Array.from(classNames);
    }
    /**
     * 替换属性中的类名
     */
    function replaceClassNames(attrs, classNameMap, targetAttr) {
        let result = attrs;
        classNameMap.forEach((safeName, originalName) => {
            const escapedName = escapeRegex(originalName);
            const regex = new RegExp(`(?<=^|[\\s'"\`\\[\\{,])${escapedName}(?=[\\s'"\`\\]\\},]|$)`, "g");
            if (targetAttr) {
                // 只在指定属性中替换
                const attrMatch = extractAttribute(result, targetAttr);
                if (attrMatch) {
                    const newValue = attrMatch.value.replace(regex, safeName);
                    if (newValue !== attrMatch.value) {
                        const prefix = attrMatch.fullMatch.startsWith(" ") ? " " : "";
                        result = result.replace(attrMatch.fullMatch, `${prefix}${targetAttr}=${attrMatch.quote}${newValue}${attrMatch.quote}`);
                    }
                }
            }
            else {
                // 在所有位置替换
                result = result.replace(regex, safeName);
            }
        });
        return result;
    }
    function parseCode(code) {
        let needsDarkImport = false;
        // 解析所有标签
        const tags = parseAllTags(code);
        // 收集所有需要替换的内容
        const replacements = [];
        tags.forEach((tag) => {
            let newAttrs = tag.attributes;
            let modified = false;
            // 1. 提取所有类名
            const allClassNames = getClassNames(`<div${newAttrs}>`);
            // 2. 构建类名转换映射
            const classNameMap = new Map();
            const darkClassNameMap = new Map();
            allClassNames.forEach((name) => {
                if (!isTailwindClass(name))
                    return;
                if (name.startsWith("dark:")) {
                    // dark: 类名：转换所有特殊字符（包括冒号），用于 :pt
                    const safeName = toSafeClassWithDark(name);
                    if (safeName !== name) {
                        darkClassNameMap.set(name, safeName);
                    }
                }
                else {
                    // 非 dark: 类名：用于所有属性
                    const safeName = toSafeClass(name);
                    if (safeName !== name) {
                        classNameMap.set(name, safeName);
                    }
                }
            });
            // 3. 替换非 dark: 类名（在所有属性中）
            if (classNameMap.size > 0) {
                const newValue = replaceClassNames(newAttrs, classNameMap);
                if (newValue !== newAttrs) {
                    newAttrs = newValue;
                    modified = true;
                }
            }
            // 4. 替换 dark: 类名（只在 :pt 属性中）
            if (darkClassNameMap.size > 0) {
                const newValue = replaceClassNames(newAttrs, darkClassNameMap, ":pt");
                if (newValue !== newAttrs) {
                    newAttrs = newValue;
                    modified = true;
                }
            }
            // 5. 处理 class 和 :class 中的 dark: 类名
            if (!config.isPlugin) {
                const darkClassNames = getClassNamesExcludingPt(`<div${newAttrs}>`).filter((name) => name.startsWith("dark:"));
                if (darkClassNames.length > 0) {
                    const darkResult = handleDarkMode(newAttrs, darkClassNames);
                    if (darkResult.modified) {
                        newAttrs = darkResult.attrs;
                        modified = true;
                        needsDarkImport = true;
                    }
                }
            }
            if (modified) {
                replacements.push({
                    start: tag.startPos,
                    end: tag.endPos,
                    newTag: `<${tag.tagName}${newAttrs}${tag.closing}`
                });
            }
        });
        // 应用所有替换（从后往前，避免位置偏移）
        let result = code;
        replacements.reverse().forEach(({ start, end, newTag }) => {
            result = result.substring(0, start) + newTag + result.substring(end);
        });
        // 添加暗黑模式导入
        if (needsDarkImport && result !== code) {
            if (!result.includes("<script")) {
                result += '\n<script lang="ts" setup></script>';
            }
            // 检查 script 标签中是否已经有 __isDark 导入
            if (!result.includes("isDark as __isDark")) {
                result = addScriptContent(result, `import { isDark as __isDark } from "@/.cool";`);
            }
        }
        // 清理空属性
        result = result.replace(/\s+:class=(["'])[\s]*\1/g, "").replace(/\s+class=(["'])[\s]*\1/g, "");
        return result !== code ? result : null;
    }
    function parseAllTags(code) {
        const tags = [];
        let i = 0;
        while (i < code.length) {
            // 查找下一个标签开始
            const tagStart = code.indexOf("<", i);
            if (tagStart === -1)
                break;
            // 跳过注释
            if (code.substring(tagStart, tagStart + 4) === "<!--") {
                const commentEnd = code.indexOf("-->", tagStart + 4);
                i = commentEnd !== -1 ? commentEnd + 3 : code.length;
                continue;
            }
            // 跳过结束标签
            if (code[tagStart + 1] === "/") {
                const tagEnd = code.indexOf(">", tagStart + 2);
                i = tagEnd !== -1 ? tagEnd + 1 : code.length;
                continue;
            }
            // 提取标签名
            const tagNameMatch = code.substring(tagStart + 1).match(/^([a-zA-Z][\w-]*)/);
            if (!tagNameMatch) {
                i = tagStart + 1;
                continue;
            }
            const tagName = tagNameMatch[1];
            const tagNameEnd = tagStart + 1 + tagName.length;
            // 查找标签结束
            let pos = tagNameEnd;
            let inString = false;
            let stringChar = "";
            let depth = 0;
            while (pos < code.length) {
                const char = code[pos];
                if (!inString) {
                    if (char === '"' || char === "'" || char === "`") {
                        inString = true;
                        stringChar = char;
                    }
                    else if (char === "{") {
                        depth++;
                    }
                    else if (char === "}") {
                        depth--;
                    }
                    else if (char === ">" && depth === 0) {
                        // 找到标签结束
                        let attributes = code.substring(tagNameEnd, pos);
                        const isSelfClosing = code[pos - 1] === "/";
                        // 如果是自闭合标签，从 attributes 中移除末尾的空格和 /
                        if (isSelfClosing) {
                            attributes = attributes.replace(/\s*\/$/, "");
                        }
                        const closing = isSelfClosing ? " />" : ">";
                        const fullTag = code.substring(tagStart, pos + 1);
                        tags.push({
                            fullTag,
                            tagName,
                            attributes,
                            closing,
                            startPos: tagStart,
                            endPos: pos + 1
                        });
                        i = pos + 1;
                        break;
                    }
                }
                else {
                    if (char === stringChar && code[pos - 1] !== "\\") {
                        inString = false;
                        stringChar = "";
                    }
                }
                pos++;
            }
            if (pos >= code.length) {
                i = code.length;
            }
        }
        return tags;
    }
    function handleDarkMode(attrs, darkClassNames) {
        let newAttrs = attrs;
        let modified = false;
        // 过滤掉包含空格的字符串（不是单个类名），并转换为安全类名
        const validDarkClassNames = darkClassNames.filter((name) => !name.includes(" "));
        const safeDarkClassNames = validDarkClassNames.map((name) => toSafeClass(name));
        // 从静态 class 中移除 dark: 类名
        const staticClassMatch = extractAttribute(newAttrs, "class");
        if (staticClassMatch) {
            let newClassValue = staticClassMatch.value;
            validDarkClassNames.forEach((originalName) => {
                const escapedName = escapeRegex(originalName);
                const regex = new RegExp(`(?:^|\\s)(${escapedName})(?=\\s|$)`, "g");
                newClassValue = newClassValue.replace(regex, (match) => match.startsWith(" ") ? " " : "");
            });
            newClassValue = newClassValue.replace(/\s+/g, " ").trim();
            if (newClassValue !== staticClassMatch.value) {
                const prefix = staticClassMatch.fullMatch.startsWith(" ") ? " " : "";
                newAttrs = newAttrs.replace(staticClassMatch.fullMatch, newClassValue
                    ? `${prefix}class=${staticClassMatch.quote}${newClassValue}${staticClassMatch.quote}`
                    : "");
                modified = true;
            }
        }
        // 生成暗黑模式对象
        const darkClassObject = safeDarkClassNames.map((name) => `'${name}': __isDark`).join(", ");
        // 处理动态 :class
        const dynamicClassMatch = extractAttribute(newAttrs, ":class");
        if (!dynamicClassMatch) {
            newAttrs += ` :class="{${darkClassObject}}"`;
            modified = true;
        }
        else {
            let newClassValue = dynamicClassMatch.value.trim();
            // 删除 dark: 类名
            validDarkClassNames.forEach((originalName, index) => {
                const safeName = safeDarkClassNames[index];
                const escapedOriginal = escapeRegex(originalName);
                const escapedSafe = escapeRegex(safeName);
                // 删除键值对
                newClassValue = newClassValue
                    .replace(new RegExp(`(['"\`])${escapedOriginal}\\1\\s*:\\s*[^,}\\]]+`, "g"), "")
                    .replace(new RegExp(`(['"\`])${escapedSafe}\\1\\s*:\\s*[^,}\\]]+`, "g"), "");
                // 删除字符串中的类名
                newClassValue = newClassValue.replace(/(['"`])([^'"`]+)\1/g, (match, quote, content) => {
                    if (!content.includes(originalName) && !content.includes(safeName)) {
                        return match;
                    }
                    let newContent = content
                        .replace(new RegExp(`\\b${escapedOriginal}\\b`, "g"), "")
                        .replace(new RegExp(`(?:^|\\s)${escapedSafe}(?=\\s|$)`, "g"), "")
                        .replace(/\s+/g, " ")
                        .trim();
                    return newContent ? `${quote}${newContent}${quote}` : "";
                });
            });
            // 清理多余的逗号和空格
            newClassValue = newClassValue
                .replace(/['"`]['"`]/g, "")
                .replace(/,\s*,+/g, ",")
                .replace(/\[\s*,+/g, "[")
                .replace(/,+\s*\]/g, "]")
                .replace(/\{\s*,+/g, "{")
                .replace(/,+\s*\}/g, "}")
                .replace(/\s+/g, " ");
            // 合并暗黑模式对象
            if (newClassValue.startsWith("{") && newClassValue.endsWith("}")) {
                const inner = newClassValue.slice(1, -1).trim();
                newClassValue = inner ? `{${darkClassObject}, ${inner}}` : `{${darkClassObject}}`;
            }
            else if (newClassValue.startsWith("[") && newClassValue.endsWith("]")) {
                newClassValue = `[{${darkClassObject}}, ${newClassValue.slice(1)}`;
            }
            else {
                newClassValue = `[{${darkClassObject}}, ${newClassValue}]`;
            }
            const prefix = dynamicClassMatch.fullMatch.startsWith(" ") ? " " : "";
            newAttrs = newAttrs.replace(dynamicClassMatch.fullMatch, `${prefix}:class=${dynamicClassMatch.quote}${newClassValue}${dynamicClassMatch.quote}`);
            modified = true;
        }
        return { attrs: newAttrs, modified };
    }
    function extractAttribute(attrs, attrName) {
        // Match attribute name with space before it (or start of string) to avoid matching :class when looking for class
        const regex = new RegExp(`(?:^|\\s)(${escapeRegex(attrName)})=`, "g");
        const match = regex.exec(attrs);
        if (!match)
            return null;
        const startPos = match.index + match[0].length;
        if (startPos >= attrs.length)
            return null;
        const quote = attrs[startPos];
        if (quote !== '"' && quote !== "'" && quote !== "`")
            return null;
        // 查找匹配的结束引号
        let pos = startPos + 1;
        let depth = 0;
        let inString = false;
        let stringChar = "";
        while (pos < attrs.length) {
            const char = attrs[pos];
            if (char === "\\") {
                pos += 2;
                continue;
            }
            if (!inString) {
                if ((char === '"' || char === "'" || char === "`") && char !== quote) {
                    inString = true;
                    stringChar = char;
                }
                else if (char === "{" || char === "[" || char === "(") {
                    depth++;
                }
                else if (char === "}" || char === "]" || char === ")") {
                    depth--;
                }
                else if (char === quote && depth === 0) {
                    const value = attrs.substring(startPos + 1, pos);
                    // Include the space/start in fullMatch
                    const fullMatch = attrs.substring(match.index, pos + 1);
                    return { fullMatch, value, quote };
                }
            }
            else {
                if (char === stringChar && attrs[pos - 1] !== "\\") {
                    inString = false;
                    stringChar = "";
                }
            }
            pos++;
        }
        return null;
    }
    function escapeRegex(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    // test();

    function tailwindPlugin() {
        return [cssPlugin(), classPlugin()];
    }

    async function createCtx() {
        let ctx = {};
        const manifest = readFile(rootDir("manifest.json"), true);
        // 文件路径
        const ctxPath = rootDir("pages.json");
        // 页面配置
        ctx = readFile(ctxPath, true);
        // 原数据，做更新比较用
        const ctxData = lodash.cloneDeep(ctx);
        // 删除临时页面
        ctx.pages = ctx.pages?.filter((e) => !e.isTemp);
        ctx.subPackages = ctx.subPackages?.filter((e) => !e.isTemp);
        // 删除不需要的数据
        for (const i in ctx) {
            if (!["pages", "subPackages", "tabBar", "globalStyle", "uniIdRouter"].includes(i)) {
                delete ctx[i];
            }
        }
        // 加载 uni_modules 配置文件
        const files = await glob.glob(rootDir("uni_modules") + "/**/pages_init.json", {
            stat: true,
            withFileTypes: true
        });
        for (const file of files) {
            if (file.isFile()) {
                const { pages = [], subPackages = [] } = readFile(path.join(file.path, file.name), true);
                // 合并到 pages 中
                [...pages, ...subPackages].forEach((e) => {
                    e.isTemp = true;
                    const isSub = !!e.root;
                    const d = isSub
                        ? ctx.subPackages?.find((a) => a.root == e.root)
                        : ctx.pages?.find((a) => a.path == e.path);
                    if (d) {
                        lodash.assign(d, e);
                    }
                    else {
                        if (isSub) {
                            ctx.subPackages?.unshift(e);
                        }
                        else {
                            ctx.pages?.unshift(e);
                        }
                    }
                });
            }
        }
        // 排序后检测，避免加载顺序问题
        function order(d) {
            return {
                pages: lodash.orderBy(d.pages, "path"),
                subPackages: lodash.orderBy(d.subPackages, "root")
            };
        }
        // 是否需要更新 pages.json
        if (!util.isDeepStrictEqual(order(ctxData), order(ctx))) {
            console.log("[cool-ctx] pages updated");
            writeFile(ctxPath, JSON.stringify(ctx, null, 4));
        }
        // appid
        ctx.appid = manifest.appid;
        return ctx;
    }
    function ctxPlugin() {
        return {
            name: "vite-cool-unix-ctx",
            enforce: "pre",
            async transform(code, id) {
                if (id.includes("/ctx/index.ts") && id.includes("cool/")) {
                    const ctx = await createCtx();
                    // 主题配置
                    const theme = readFile(rootDir("theme.json"), true);
                    // 主题配置
                    ctx["theme"] = theme || {};
                    // 颜色值
                    ctx["color"] = getTailwindColor();
                    if (!ctx.subPackages) {
                        ctx.subPackages = [];
                    }
                    if (!ctx.tabBar) {
                        ctx.tabBar = {};
                    }
                    if (!ctx.uniIdRouter) {
                        ctx.uniIdRouter = {};
                    }
                    let ctxCode = JSON.stringify(ctx, null, 4);
                    ctxCode = ctxCode.replace(`"tabBar": {}`, `"tabBar": {} as TabBar`);
                    ctxCode = ctxCode.replace(`"subPackages": []`, `"subPackages": [] as SubPackage[]`);
                    code = code.replace("const ctx = {}", `const ctx = ${ctxCode}`);
                    code = code.replace("const ctx = parse<Ctx>({})!", `const ctx = parse<Ctx>(${ctxCode})!`);
                }
                if (id.endsWith(".json")) {
                    const d = JSON.parse(code);
                    // 转字符串，不然会报错：Method too large
                    if (id.includes("/locales/")) {
                        let t = [];
                        d.forEach(([a, b]) => {
                            t.push(`${a}<__=__>${b}`);
                        });
                        code = JSON.stringify([[t.join("<__&__>")]]);
                    }
                    else {
                        code = JSON.stringify(d);
                    }
                }
                return {
                    code,
                    map: { mappings: "" }
                };
            }
        };
    }

    function jsonPlugin() {
        return {
            name: "vite-cool-unix-json",
            transform(code, id) {
                if (id.endsWith(".json")) {
                    return {
                        code: code.replace("new UTSJSONObject", ""),
                        map: { mappings: "" }
                    };
                }
            }
        };
    }
    function tsPlugin() {
        return {
            name: "vite-cool-unix-ts",
            enforce: "pre",
            transform(code, id) {
                // 处理 main.ts 或 main.uts 文件，自动注入插件导入和使用代码
                if (id.endsWith("/main.ts") || id.endsWith("/main.uts")) {
                    const pluginDirectory = rootDir("plugins");
                    let pluginFiles = [];
                    try {
                        // 读取插件目录下的所有文件
                        pluginFiles = fs.readdirSync(pluginDirectory);
                    }
                    catch (error) {
                        // 忽略错误
                    }
                    // 提取插件文件名（去除 .ts 扩展名）
                    const pluginNames = pluginFiles.map((file) => path.basename(file, ".ts"));
                    // 生成插件导入语句
                    const importStatements = pluginNames.map((pluginName) => {
                        return `import __${pluginName}Plugin from "@/plugins/${pluginName}";`;
                    });
                    // 添加 cool 导入语句
                    importStatements.unshift(`import { coolPlugin as __coolPlugin } from "./.cool/bootstrap";`);
                    // 找到 export function createApp() 的位置
                    const appUvueIndex = getCodeIndex(/export\s+function\s+createApp\(\)/, code);
                    if (appUvueIndex != -1) {
                        // 在前面添加导入语句
                        code =
                            code.slice(0, appUvueIndex) +
                                importStatements.join("\n") +
                                "\n" +
                                code.slice(appUvueIndex);
                        // 生成插件使用语句
                        const useStatements = pluginNames.map((pluginName) => {
                            return `__${pluginName}Plugin.install(app);`;
                        });
                        // 添加 cool 使用语句
                        useStatements.unshift(`__coolPlugin(app);`);
                        // 找到 createSSRApp(App) 的位置，在其后插入插件使用代码
                        const createSSRAppIndex = getCodeIndex(/createSSRApp\(App\);/s, code, true);
                        if (createSSRAppIndex != -1) {
                            // 在指定位置插入插件使用代码
                            code =
                                code.slice(0, createSSRAppIndex) +
                                    "\n" +
                                    useStatements.join("\n") +
                                    code.slice(createSSRAppIndex);
                        }
                    }
                    return {
                        code,
                        map: { mappings: "" }
                    };
                }
            }
        };
    }
    function uvuePlugin() {
        return {
            name: "vite-cool-unix-uvue",
            enforce: "pre",
            transform(code, id) {
                if (id.endsWith("/App.uvue")) {
                    // 找到 <script lang="uts"> 的位置
                    const scriptIndex = getCodeIndex(/<script lang="uts">/, code) + 19;
                    if (scriptIndex != -1) {
                        // 在后面添加导入语句
                        code =
                            code.slice(0, scriptIndex) + '\nimport "./.cool";' + code.slice(scriptIndex);
                    }
                    code =
                        code +
                            `<style lang="scss">
      @import "@/.cool/index.scss";
       </style>`;
                    return {
                        code,
                        map: { mappings: "" }
                    };
                }
            }
        };
    }
    function localePlugin() {
        return {
            name: "vite-cool-unix-locales",
            enforce: "pre",
            transform(code, id) {
                if (id.endsWith("/plugins/locale.ts")) {
                    // 找到所有的 locales 文件
                    const files = glob.globSync(rootDir("/") + "**/locales/*.json", {
                        withFileTypes: true
                    });
                    const importStatements = [
                        `import { appendLocale as __appendLocale } from "@/.cool";`
                    ];
                    const useStatements = [];
                    // 遍历所有 locales 目录下的 JSON 文件，自动生成 import 和 appendLocale 语句
                    for (const file of files) {
                        // 确保是文件类型
                        if (!file.isFile())
                            continue;
                        // 获取父级目录名（假如没有则为 base），将中划线替换为下划线，避免变量非法
                        const pName = file.parent?.parent?.name?.replace(/-/g, "_") || "base";
                        // 文件相对路径，统一使用正斜杠
                        const relativePath = file.path.replace(/\\/g, "/").replace(rootDir("/"), "");
                        // 仅处理 .json 文件
                        if (!file.name.endsWith(".json"))
                            continue;
                        // 文件名去后缀，变量名同样替换 - 为 _
                        const fileName = path.basename(file.name, ".json");
                        const varName = `loale_${pName}_${fileName.replace(/-/g, "_")}`;
                        // 添加导入声明（import xxx from ...）
                        importStatements.push(`import ${varName} from "@/${relativePath}/${file.name}";`);
                        // 生成 appendLocale 语句
                        const useStatement = `__appendLocale("${fileName}", ${varName});`;
                        // 若是 uni_modules 路径，import 排到后面，非 uni_modules 路径优先
                        if (relativePath.includes("uni_modules")) {
                            useStatements.push(useStatement);
                        }
                        else {
                            useStatements.unshift(useStatement);
                        }
                    }
                    // 添加导入语句
                    code = importStatements.join("\n") + "\n" + code;
                    // 找到 install(app) { 的位置
                    const installIndex = getCodeIndex(/install\s*\(\s*app\s*\)\s*\{/s, code, true);
                    if (installIndex != -1) {
                        // 在指定位置插入 appendLocale 使用语句
                        code =
                            code.slice(0, installIndex) +
                                "\n" +
                                useStatements.join("\n") +
                                code.slice(installIndex);
                    }
                    return {
                        code,
                        map: { mappings: "" }
                    };
                }
            }
        };
    }
    function codePlugin() {
        return [jsonPlugin(), tsPlugin(), uvuePlugin(), localePlugin()];
    }

    function cool(options) {
        // 请求地址
        config.reqUrl = getProxyTarget(options.proxy);
        // 编译平台
        config.utsPlatform = process.env.UNI_UTS_PLATFORM ?? "web";
        // 是否为插件
        config.isPlugin = options.isPlugin ?? false;
        // tailwind
        if (options.tailwind) {
            lodash.assign(config.tailwind, options.tailwind);
        }
        // 插件
        const plugins = [...codePlugin(), ctxPlugin()];
        if (config.tailwind.enable) {
            plugins.push(...tailwindPlugin());
        }
        return plugins;
    }

    exports.cool = cool;

}));
